---
layout: post
title: 前后端解耦的一点尝试
date: 2013-02-10 23:24:33
comments: true
tags:
---

摊子大了，分工就会细化。这过程中难免产生沟通的沟渠，需要靠流程的优化，工具的完善来弥补。这里就讲讲自己在工作中的一些尝试，也算抛砖引玉吧。

我在公司的情况是，业务线众多，有各自的前后端同学负责。同时页面中的交互也比较繁多复杂，常常会有5到10个ajax接口，有已有的也有开发中的。由于后端的应用是分开的，所以在商户应用的开发环境中，可能就会没有用户登录这种账户相关的功能。

同时，前端开发的同学这边，也苦恼于没有后端数据。以前有过后端同学过来帮忙配java环境，一配一下午的黑历史。后来也常常自己造一些假数据，一般是一些文本文件，拿fiddler或者charles一类的工具代理过来，但我觉得本地文件不是mock数据的最终归宿。

开发之前先约定好接口，这是大型开发中的好实践，也是大家一致认可的做法。但接口要怎么描述。接口文档除了供人参阅，有没有更多的价值。能不能让双方的约定可以被执行，被使用，而不仅仅是一个约定这么简单呢？

妈蛋毫无压力啊！

来看，我们做约定的时候一般是这样的：

有一个url，/ajax/json/shop/reviewflower，用来送送鲜花什么的。关于它，我们说好，当发送GET请求，包含以下参数

``` javascript
action=aa // 表示送花，必须为"aa" 
id=123456789 // 对象id，一串七位数字
type=1  // 表示鲜花目标的类型为点评，可以是1,2,3
```

然后期待<del>卖花小妹</del>后端返回

```
{
	"code":200, // 一定得是200
	"msg":"have a nice day" // 一个字符串可以是其他内容
}
```

那么这里的需求其实是，对于前端，我给出匹配一定模式的的请求，就把我准备好的假数据给我。对于后端，固定的请求发给我，请为我验证我返回的数据是否符合格式。

于是就有这样的数据结构：

**reqschema**

``` javascript
{
	get:{
		"actione":"aa",
		"id":String.of(8,"0123456789"),
		"type":["1","2","3"]
	},
	header:{
		"cookie":{
			"login_session":String
		}
	}
}
```

**resdata**

``` javascript
{
	"code":200,
	"msg":"have a nice day" 
}
```

后端关注

**reqdata**

``` javascript
{
	"get":{	
		"action":"aa",
		"id":"123456789",
		"type":"1"	
	},
	"header":{
		"cookie":{
			"login_session":"AQWEAFEWRQWEASGWET"
		}
	}
}
```

**resschema**

``` javascript
{
	"code":200,
	"msg":String
}
```

这样就好了。然后我们的工具中存着这些数据，以及对应的url和功能点。写一个express的[中间件](https://gist.github.com/supersheep/4753352)用于给前端返回假数据。再写个[验证器](https://gist.github.com/supersheep/4753364)用于给后端同学验证自己接口的正确性，就大功告成了。代码就不丢这里占篇幅了，大家点前面两个链接看gist就好，写那么长不是我本意。

这里验证schema用到了[js-schema](https://github.com/molnarg/js-schema/)这个模块，真的是我所见过api最通俗易懂好阅读的schema验证器了。原来第一版的时候使用的方式是写should.js的testcase，然后编译成一组function来验证，还挺自鸣得意，后来用起来才觉得自己当初的设计实在是太反人类了。js-schema唯一的缺憾是报错信息不够细致，但是已经在作者的todo list里了，各位同学如果觉得好也可以踊跃fork。

结耦的事情差不多就是这样了，我管他叫`TADA`，各种不完善而且和公司的特点结合的有点紧，就不丢出来了。其实后来投入使用，感觉对于后端自测接口的意义并不是很大，毕竟有人家有JUnit之类。况且作为完全的黑盒，有些功能也很难按这种简单的方式进行衡量。比如送鲜花的接口判断已经送过了，就会返回 `{"code":403,"msg":"one is enough"}` ，那就只好写成[pattern1,pattern2,…]的形式来进行匹配了。尽管如此，作为测试同学发现问题的入口，以及整站接口的管理者存在，我想他还是有其价值的吧。

做完这些，就大可以在后端还没完成开发的时候，从这里代理数据了。但我还是不太情愿开我那迟迟未破解，用30分钟就会自动关闭的charles。为什么非得是我们把个别静态文件代理到本地来呢。就不能是访问本地的静态server，而对测试环境的接口做代理么。这样一想就有了cortex server（cortex是公司里用来做静态资源打包发布的工具，也是才用起来还有太多值得改进的地方不细讲。cortex server原来是自己的一个叫kicker的项目，但是后来实践的过程中觉得干嘛让大家装那么多乱七八糟的工具，一条龙多好，或许有一天想法成熟了，会重新脱离出来吧）

于是，在home目录下，建立.cortex文件夹，添加server.json的配置如下。

``` javascript
{
	"port":1337,
	"fallback":"w.alpha.dp",
	"replace":[
		["i1.static.dp","localhost:1337"],
		["i2.static.dp","localhost:1337"],
		["i3.static.dp","localhost:1337"]
	]
}
```

然后当本地的找不到对应文件的时候，就将请求整个代理到w.alpha.dp上去。如果该接口后端同学还在本地调试，那就代理去他的机器就好。终于不用大家都发布到测试环境才能发现问题了。要是后端同学甚至还没开工，那么再加一个配置，优先尝试将其代理到tada上去，也是很方便的。更进一步，如果要在这个本地server上，做less，sass，stylus，以及coffeescript的动态编译，要在server启动的时候去读项目配置种的combo规则来准备好combo请求的响应，相信也都是很容易实现的。

老实说最终越是让自己得意，并且觉得好用的作品，花的力气反倒越是少。是因为懂得善用他人的成果，也因为犯过的错误，而更明白怎样才是一个好方案了吧我想。思考前后端合作的方式，弄清该抓哪些放哪些也是蛮重要的。比如我原来打算让一个页面也可以写成testcase，做法是引入node jQuery，来判断页面上是否有某id的元素。但实际页面的情况比这要复杂的多，而且后来我慢慢也更倾向于认为，推动模板层面的事情慢慢往前端挪才是正经事，就没再多折腾。

就写到这里吧，是在太啰嗦了。有兴趣的同学还可以读一下InfoQ这篇[Web前后端研发模式讨论](http://www.infoq.com/cn/news/2012/06/web-front-back-development)，虽然讲的不完全是同一个事情，不过依然是很有价值的讨论呀。

















